// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'wallet_types.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

WalletInfo _$WalletInfoFromJson(Map<String, dynamic> json) {
  return _WalletInfo.fromJson(json);
}

/// @nodoc
mixin _$WalletInfo {
  String get name => throw _privateConstructorUsedError;
  String get wid => throw _privateConstructorUsedError;
  String get accountsBoxKey => throw _privateConstructorUsedError;
  String get accountsEncryptionKey => throw _privateConstructorUsedError;
  String get accountInfoBoxKey => throw _privateConstructorUsedError;
  String get accountInfoEncryptionKey => throw _privateConstructorUsedError;
  String get selectionKey => throw _privateConstructorUsedError;
  String get publicKey => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WalletInfoCopyWith<WalletInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WalletInfoCopyWith<$Res> {
  factory $WalletInfoCopyWith(
          WalletInfo value, $Res Function(WalletInfo) then) =
      _$WalletInfoCopyWithImpl<$Res, WalletInfo>;
  @useResult
  $Res call(
      {String name,
      String wid,
      String accountsBoxKey,
      String accountsEncryptionKey,
      String accountInfoBoxKey,
      String accountInfoEncryptionKey,
      String selectionKey,
      String publicKey});
}

/// @nodoc
class _$WalletInfoCopyWithImpl<$Res, $Val extends WalletInfo>
    implements $WalletInfoCopyWith<$Res> {
  _$WalletInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? wid = null,
    Object? accountsBoxKey = null,
    Object? accountsEncryptionKey = null,
    Object? accountInfoBoxKey = null,
    Object? accountInfoEncryptionKey = null,
    Object? selectionKey = null,
    Object? publicKey = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      wid: null == wid
          ? _value.wid
          : wid // ignore: cast_nullable_to_non_nullable
              as String,
      accountsBoxKey: null == accountsBoxKey
          ? _value.accountsBoxKey
          : accountsBoxKey // ignore: cast_nullable_to_non_nullable
              as String,
      accountsEncryptionKey: null == accountsEncryptionKey
          ? _value.accountsEncryptionKey
          : accountsEncryptionKey // ignore: cast_nullable_to_non_nullable
              as String,
      accountInfoBoxKey: null == accountInfoBoxKey
          ? _value.accountInfoBoxKey
          : accountInfoBoxKey // ignore: cast_nullable_to_non_nullable
              as String,
      accountInfoEncryptionKey: null == accountInfoEncryptionKey
          ? _value.accountInfoEncryptionKey
          : accountInfoEncryptionKey // ignore: cast_nullable_to_non_nullable
              as String,
      selectionKey: null == selectionKey
          ? _value.selectionKey
          : selectionKey // ignore: cast_nullable_to_non_nullable
              as String,
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_WalletInfoCopyWith<$Res>
    implements $WalletInfoCopyWith<$Res> {
  factory _$$_WalletInfoCopyWith(
          _$_WalletInfo value, $Res Function(_$_WalletInfo) then) =
      __$$_WalletInfoCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      String wid,
      String accountsBoxKey,
      String accountsEncryptionKey,
      String accountInfoBoxKey,
      String accountInfoEncryptionKey,
      String selectionKey,
      String publicKey});
}

/// @nodoc
class __$$_WalletInfoCopyWithImpl<$Res>
    extends _$WalletInfoCopyWithImpl<$Res, _$_WalletInfo>
    implements _$$_WalletInfoCopyWith<$Res> {
  __$$_WalletInfoCopyWithImpl(
      _$_WalletInfo _value, $Res Function(_$_WalletInfo) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? wid = null,
    Object? accountsBoxKey = null,
    Object? accountsEncryptionKey = null,
    Object? accountInfoBoxKey = null,
    Object? accountInfoEncryptionKey = null,
    Object? selectionKey = null,
    Object? publicKey = null,
  }) {
    return _then(_$_WalletInfo(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      wid: null == wid
          ? _value.wid
          : wid // ignore: cast_nullable_to_non_nullable
              as String,
      accountsBoxKey: null == accountsBoxKey
          ? _value.accountsBoxKey
          : accountsBoxKey // ignore: cast_nullable_to_non_nullable
              as String,
      accountsEncryptionKey: null == accountsEncryptionKey
          ? _value.accountsEncryptionKey
          : accountsEncryptionKey // ignore: cast_nullable_to_non_nullable
              as String,
      accountInfoBoxKey: null == accountInfoBoxKey
          ? _value.accountInfoBoxKey
          : accountInfoBoxKey // ignore: cast_nullable_to_non_nullable
              as String,
      accountInfoEncryptionKey: null == accountInfoEncryptionKey
          ? _value.accountInfoEncryptionKey
          : accountInfoEncryptionKey // ignore: cast_nullable_to_non_nullable
              as String,
      selectionKey: null == selectionKey
          ? _value.selectionKey
          : selectionKey // ignore: cast_nullable_to_non_nullable
              as String,
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_WalletInfo implements _WalletInfo {
  const _$_WalletInfo(
      {required this.name,
      required this.wid,
      required this.accountsBoxKey,
      required this.accountsEncryptionKey,
      required this.accountInfoBoxKey,
      required this.accountInfoEncryptionKey,
      required this.selectionKey,
      required this.publicKey});

  factory _$_WalletInfo.fromJson(Map<String, dynamic> json) =>
      _$$_WalletInfoFromJson(json);

  @override
  final String name;
  @override
  final String wid;
  @override
  final String accountsBoxKey;
  @override
  final String accountsEncryptionKey;
  @override
  final String accountInfoBoxKey;
  @override
  final String accountInfoEncryptionKey;
  @override
  final String selectionKey;
  @override
  final String publicKey;

  @override
  String toString() {
    return 'WalletInfo(name: $name, wid: $wid, accountsBoxKey: $accountsBoxKey, accountsEncryptionKey: $accountsEncryptionKey, accountInfoBoxKey: $accountInfoBoxKey, accountInfoEncryptionKey: $accountInfoEncryptionKey, selectionKey: $selectionKey, publicKey: $publicKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WalletInfo &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.wid, wid) || other.wid == wid) &&
            (identical(other.accountsBoxKey, accountsBoxKey) ||
                other.accountsBoxKey == accountsBoxKey) &&
            (identical(other.accountsEncryptionKey, accountsEncryptionKey) ||
                other.accountsEncryptionKey == accountsEncryptionKey) &&
            (identical(other.accountInfoBoxKey, accountInfoBoxKey) ||
                other.accountInfoBoxKey == accountInfoBoxKey) &&
            (identical(
                    other.accountInfoEncryptionKey, accountInfoEncryptionKey) ||
                other.accountInfoEncryptionKey == accountInfoEncryptionKey) &&
            (identical(other.selectionKey, selectionKey) ||
                other.selectionKey == selectionKey) &&
            (identical(other.publicKey, publicKey) ||
                other.publicKey == publicKey));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      name,
      wid,
      accountsBoxKey,
      accountsEncryptionKey,
      accountInfoBoxKey,
      accountInfoEncryptionKey,
      selectionKey,
      publicKey);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WalletInfoCopyWith<_$_WalletInfo> get copyWith =>
      __$$_WalletInfoCopyWithImpl<_$_WalletInfo>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_WalletInfoToJson(
      this,
    );
  }
}

abstract class _WalletInfo implements WalletInfo {
  const factory _WalletInfo(
      {required final String name,
      required final String wid,
      required final String accountsBoxKey,
      required final String accountsEncryptionKey,
      required final String accountInfoBoxKey,
      required final String accountInfoEncryptionKey,
      required final String selectionKey,
      required final String publicKey}) = _$_WalletInfo;

  factory _WalletInfo.fromJson(Map<String, dynamic> json) =
      _$_WalletInfo.fromJson;

  @override
  String get name;
  @override
  String get wid;
  @override
  String get accountsBoxKey;
  @override
  String get accountsEncryptionKey;
  @override
  String get accountInfoBoxKey;
  @override
  String get accountInfoEncryptionKey;
  @override
  String get selectionKey;
  @override
  String get publicKey;
  @override
  @JsonKey(ignore: true)
  _$$_WalletInfoCopyWith<_$_WalletInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

WalletBundle _$WalletBundleFromJson(Map<String, dynamic> json) {
  return _WalletBundle.fromJson(json);
}

/// @nodoc
mixin _$WalletBundle {
  IList<WalletInfo> get wallets => throw _privateConstructorUsedError;
  WalletInfo? get selected => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WalletBundleCopyWith<WalletBundle> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WalletBundleCopyWith<$Res> {
  factory $WalletBundleCopyWith(
          WalletBundle value, $Res Function(WalletBundle) then) =
      _$WalletBundleCopyWithImpl<$Res, WalletBundle>;
  @useResult
  $Res call({IList<WalletInfo> wallets, WalletInfo? selected});

  $WalletInfoCopyWith<$Res>? get selected;
}

/// @nodoc
class _$WalletBundleCopyWithImpl<$Res, $Val extends WalletBundle>
    implements $WalletBundleCopyWith<$Res> {
  _$WalletBundleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? wallets = null,
    Object? selected = freezed,
  }) {
    return _then(_value.copyWith(
      wallets: null == wallets
          ? _value.wallets
          : wallets // ignore: cast_nullable_to_non_nullable
              as IList<WalletInfo>,
      selected: freezed == selected
          ? _value.selected
          : selected // ignore: cast_nullable_to_non_nullable
              as WalletInfo?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $WalletInfoCopyWith<$Res>? get selected {
    if (_value.selected == null) {
      return null;
    }

    return $WalletInfoCopyWith<$Res>(_value.selected!, (value) {
      return _then(_value.copyWith(selected: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_WalletBundleCopyWith<$Res>
    implements $WalletBundleCopyWith<$Res> {
  factory _$$_WalletBundleCopyWith(
          _$_WalletBundle value, $Res Function(_$_WalletBundle) then) =
      __$$_WalletBundleCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({IList<WalletInfo> wallets, WalletInfo? selected});

  @override
  $WalletInfoCopyWith<$Res>? get selected;
}

/// @nodoc
class __$$_WalletBundleCopyWithImpl<$Res>
    extends _$WalletBundleCopyWithImpl<$Res, _$_WalletBundle>
    implements _$$_WalletBundleCopyWith<$Res> {
  __$$_WalletBundleCopyWithImpl(
      _$_WalletBundle _value, $Res Function(_$_WalletBundle) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? wallets = null,
    Object? selected = freezed,
  }) {
    return _then(_$_WalletBundle(
      wallets: null == wallets
          ? _value.wallets
          : wallets // ignore: cast_nullable_to_non_nullable
              as IList<WalletInfo>,
      selected: freezed == selected
          ? _value.selected
          : selected // ignore: cast_nullable_to_non_nullable
              as WalletInfo?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_WalletBundle implements _WalletBundle {
  const _$_WalletBundle(
      {this.wallets = const IListConst<WalletInfo>([]), this.selected});

  factory _$_WalletBundle.fromJson(Map<String, dynamic> json) =>
      _$$_WalletBundleFromJson(json);

  @override
  @JsonKey()
  final IList<WalletInfo> wallets;
  @override
  final WalletInfo? selected;

  @override
  String toString() {
    return 'WalletBundle(wallets: $wallets, selected: $selected)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WalletBundle &&
            const DeepCollectionEquality().equals(other.wallets, wallets) &&
            (identical(other.selected, selected) ||
                other.selected == selected));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(wallets), selected);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WalletBundleCopyWith<_$_WalletBundle> get copyWith =>
      __$$_WalletBundleCopyWithImpl<_$_WalletBundle>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_WalletBundleToJson(
      this,
    );
  }
}

abstract class _WalletBundle implements WalletBundle {
  const factory _WalletBundle(
      {final IList<WalletInfo> wallets,
      final WalletInfo? selected}) = _$_WalletBundle;

  factory _WalletBundle.fromJson(Map<String, dynamic> json) =
      _$_WalletBundle.fromJson;

  @override
  IList<WalletInfo> get wallets;
  @override
  WalletInfo? get selected;
  @override
  @JsonKey(ignore: true)
  _$$_WalletBundleCopyWith<_$_WalletBundle> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$WalletData {
  String get name => throw _privateConstructorUsedError;
  String get seed => throw _privateConstructorUsedError;
  String? get mnemonic => throw _privateConstructorUsedError;
  String? get password => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WalletDataCopyWith<WalletData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WalletDataCopyWith<$Res> {
  factory $WalletDataCopyWith(
          WalletData value, $Res Function(WalletData) then) =
      _$WalletDataCopyWithImpl<$Res, WalletData>;
  @useResult
  $Res call({String name, String seed, String? mnemonic, String? password});
}

/// @nodoc
class _$WalletDataCopyWithImpl<$Res, $Val extends WalletData>
    implements $WalletDataCopyWith<$Res> {
  _$WalletDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? seed = null,
    Object? mnemonic = freezed,
    Object? password = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      seed: null == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as String,
      mnemonic: freezed == mnemonic
          ? _value.mnemonic
          : mnemonic // ignore: cast_nullable_to_non_nullable
              as String?,
      password: freezed == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_WalletDataCopyWith<$Res>
    implements $WalletDataCopyWith<$Res> {
  factory _$$_WalletDataCopyWith(
          _$_WalletData value, $Res Function(_$_WalletData) then) =
      __$$_WalletDataCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String seed, String? mnemonic, String? password});
}

/// @nodoc
class __$$_WalletDataCopyWithImpl<$Res>
    extends _$WalletDataCopyWithImpl<$Res, _$_WalletData>
    implements _$$_WalletDataCopyWith<$Res> {
  __$$_WalletDataCopyWithImpl(
      _$_WalletData _value, $Res Function(_$_WalletData) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? seed = null,
    Object? mnemonic = freezed,
    Object? password = freezed,
  }) {
    return _then(_$_WalletData(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      seed: null == seed
          ? _value.seed
          : seed // ignore: cast_nullable_to_non_nullable
              as String,
      mnemonic: freezed == mnemonic
          ? _value.mnemonic
          : mnemonic // ignore: cast_nullable_to_non_nullable
              as String?,
      password: freezed == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_WalletData implements _WalletData {
  const _$_WalletData(
      {required this.name, required this.seed, this.mnemonic, this.password});

  @override
  final String name;
  @override
  final String seed;
  @override
  final String? mnemonic;
  @override
  final String? password;

  @override
  String toString() {
    return 'WalletData(name: $name, seed: $seed, mnemonic: $mnemonic, password: $password)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WalletData &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.seed, seed) || other.seed == seed) &&
            (identical(other.mnemonic, mnemonic) ||
                other.mnemonic == mnemonic) &&
            (identical(other.password, password) ||
                other.password == password));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name, seed, mnemonic, password);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WalletDataCopyWith<_$_WalletData> get copyWith =>
      __$$_WalletDataCopyWithImpl<_$_WalletData>(this, _$identity);
}

abstract class _WalletData implements WalletData {
  const factory _WalletData(
      {required final String name,
      required final String seed,
      final String? mnemonic,
      final String? password}) = _$_WalletData;

  @override
  String get name;
  @override
  String get seed;
  @override
  String? get mnemonic;
  @override
  String? get password;
  @override
  @JsonKey(ignore: true)
  _$$_WalletDataCopyWith<_$_WalletData> get copyWith =>
      throw _privateConstructorUsedError;
}
